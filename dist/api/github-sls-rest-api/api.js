"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * github-sls-rest-api
 * To generate a JWT token, go to the <a href=\"https://sso.saml.to/auth/jwt.html\" target=\"_blank\">JWT Token Generator</a>
 *
 * The version of the OpenAPI document: 1.0.3-0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IDPApi = exports.IDPApiFactory = exports.IDPApiFp = exports.IDPApiAxiosParamCreator = exports.HealthApi = exports.HealthApiFactory = exports.HealthApiFp = exports.HealthApiAxiosParamCreator = exports.GithubSlsRestApiNameIdFormatV1 = exports.GithubSlsRestApiConfigV20220101VersionEnum = exports.GithubSlsRestApiConfigBase20220101VersionEnum = exports.GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1VersionEnum = exports.GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1TypeEnum = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 *
 * @export
 * @enum {string}
 */
var GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1TypeEnum;
(function (GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1TypeEnum) {
    GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1TypeEnum["GithubLoginTokenEvent"] = "GithubLoginTokenEvent";
})(GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1TypeEnum = exports.GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1TypeEnum || (exports.GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1TypeEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1VersionEnum;
(function (GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1VersionEnum) {
    GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1VersionEnum[GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1VersionEnum["NUMBER_1"] = 1] = "NUMBER_1";
})(GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1VersionEnum = exports.GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1VersionEnum || (exports.GithubSlsRestApiAuthSlsRestApiGithubLoginTokenEventV1VersionEnum = {}));
/**
    * @export
    * @enum {string}
    */
var GithubSlsRestApiConfigBase20220101VersionEnum;
(function (GithubSlsRestApiConfigBase20220101VersionEnum) {
    GithubSlsRestApiConfigBase20220101VersionEnum["_20220101"] = "20220101";
})(GithubSlsRestApiConfigBase20220101VersionEnum = exports.GithubSlsRestApiConfigBase20220101VersionEnum || (exports.GithubSlsRestApiConfigBase20220101VersionEnum = {}));
/**
    * @export
    * @enum {string}
    */
var GithubSlsRestApiConfigV20220101VersionEnum;
(function (GithubSlsRestApiConfigV20220101VersionEnum) {
    GithubSlsRestApiConfigV20220101VersionEnum["_20220101"] = "20220101";
})(GithubSlsRestApiConfigV20220101VersionEnum = exports.GithubSlsRestApiConfigV20220101VersionEnum || (exports.GithubSlsRestApiConfigV20220101VersionEnum = {}));
/**
 *
 * @export
 * @enum {string}
 */
var GithubSlsRestApiNameIdFormatV1;
(function (GithubSlsRestApiNameIdFormatV1) {
    GithubSlsRestApiNameIdFormatV1["Id"] = "id";
    GithubSlsRestApiNameIdFormatV1["Login"] = "login";
    GithubSlsRestApiNameIdFormatV1["Email"] = "email";
    GithubSlsRestApiNameIdFormatV1["EmailV2"] = "emailV2";
})(GithubSlsRestApiNameIdFormatV1 = exports.GithubSlsRestApiNameIdFormatV1 || (exports.GithubSlsRestApiNameIdFormatV1 = {}));
/**
 * HealthApi - axios parameter creator
 * @export
 */
const HealthApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (options = {}) => {
            const localVarPath = `/api/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.HealthApiAxiosParamCreator = HealthApiAxiosParamCreator;
/**
 * HealthApi - functional programming interface
 * @export
 */
const HealthApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.HealthApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.HealthApiFp = HealthApiFp;
/**
 * HealthApi - factory interface
 * @export
 */
const HealthApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.HealthApiFp)(configuration);
    return {
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(options) {
            return localVarFp.get(options).then((request) => request(axios, basePath));
        },
    };
};
exports.HealthApiFactory = HealthApiFactory;
/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
class HealthApi extends base_1.BaseAPI {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    get(options) {
        return (0, exports.HealthApiFp)(this.configuration).get(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.HealthApi = HealthApi;
/**
 * IDPApi - axios parameter creator
 * @export
 */
const IDPApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {string} role
         * @param {string} [org]
         * @param {string} [provider]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assumeRole: async (role, org, provider, options = {}) => {
            // verify required parameter 'role' is not null or undefined
            (0, common_1.assertParamExists)('assumeRole', 'role', role);
            const localVarPath = `/api/v1/idp/roles/{role}/assume`
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }
            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} org
         * @param {GithubSlsRestApiEncryptRequest} githubSlsRestApiEncryptRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encrypt: async (org, githubSlsRestApiEncryptRequest, options = {}) => {
            // verify required parameter 'org' is not null or undefined
            (0, common_1.assertParamExists)('encrypt', 'org', org);
            // verify required parameter 'githubSlsRestApiEncryptRequest' is not null or undefined
            (0, common_1.assertParamExists)('encrypt', 'githubSlsRestApiEncryptRequest', githubSlsRestApiEncryptRequest);
            const localVarPath = `/api/v1/idp/orgs/{org}/encrypt`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(githubSlsRestApiEncryptRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} org
         * @param {boolean} [raw]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgConfig: async (org, raw, options = {}) => {
            // verify required parameter 'org' is not null or undefined
            (0, common_1.assertParamExists)('getOrgConfig', 'org', org);
            const localVarPath = `/api/v1/idp/orgs/{org}/config`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (raw !== undefined) {
                localVarQueryParameter['raw'] = raw;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} org
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgMetadata: async (org, options = {}) => {
            // verify required parameter 'org' is not null or undefined
            (0, common_1.assertParamExists)('getOrgMetadata', 'org', org);
            const localVarPath = `/api/v1/idp/orgs/{org}/metadata`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [org]
         * @param {boolean} [refresh]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogins: async (org, refresh, options = {}) => {
            const localVarPath = `/api/v1/idp/logins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }
            if (refresh !== undefined) {
                localVarQueryParameter['refresh'] = refresh;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgRepos: async (options = {}) => {
            const localVarPath = `/api/v1/idp/orgs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} [org]
         * @param {string} [provider]
         * @param {boolean} [refresh]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles: async (org, provider, refresh, options = {}) => {
            const localVarPath = `/api/v1/idp/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }
            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }
            if (refresh !== undefined) {
                localVarQueryParameter['refresh'] = refresh;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} provider
         * @param {string} [org]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerLogin: async (provider, org, options = {}) => {
            // verify required parameter 'provider' is not null or undefined
            (0, common_1.assertParamExists)('providerLogin', 'provider', provider);
            const localVarPath = `/api/v1/idp/logins/{provider}/login`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (org !== undefined) {
                localVarQueryParameter['org'] = org;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {string} org
         * @param {string} repo
         * @param {boolean} [force]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrgAndRepo: async (org, repo, force, options = {}) => {
            // verify required parameter 'org' is not null or undefined
            (0, common_1.assertParamExists)('setOrgAndRepo', 'org', org);
            // verify required parameter 'repo' is not null or undefined
            (0, common_1.assertParamExists)('setOrgAndRepo', 'repo', repo);
            const localVarPath = `/api/v1/idp/orgs/{org}/repos/{repo}`
                .replace(`{${"org"}}`, encodeURIComponent(String(org)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication jwt required
            // http bearer authentication required
            await (0, common_1.setBearerAuthToObject)(localVarHeaderParameter, configuration);
            if (force !== undefined) {
                localVarQueryParameter['force'] = force;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.IDPApiAxiosParamCreator = IDPApiAxiosParamCreator;
/**
 * IDPApi - functional programming interface
 * @export
 */
const IDPApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.IDPApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {string} role
         * @param {string} [org]
         * @param {string} [provider]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assumeRole(role, org, provider, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assumeRole(role, org, provider, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} org
         * @param {GithubSlsRestApiEncryptRequest} githubSlsRestApiEncryptRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async encrypt(org, githubSlsRestApiEncryptRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.encrypt(org, githubSlsRestApiEncryptRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} org
         * @param {boolean} [raw]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgConfig(org, raw, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgConfig(org, raw, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} org
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrgMetadata(org, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrgMetadata(org, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} [org]
         * @param {boolean} [refresh]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLogins(org, refresh, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLogins(org, refresh, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOrgRepos(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOrgRepos(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} [org]
         * @param {string} [provider]
         * @param {boolean} [refresh]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoles(org, provider, refresh, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoles(org, provider, refresh, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} provider
         * @param {string} [org]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerLogin(provider, org, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerLogin(provider, org, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @param {string} org
         * @param {string} repo
         * @param {boolean} [force]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOrgAndRepo(org, repo, force, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOrgAndRepo(org, repo, force, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.IDPApiFp = IDPApiFp;
/**
 * IDPApi - factory interface
 * @export
 */
const IDPApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.IDPApiFp)(configuration);
    return {
        /**
         *
         * @param {string} role
         * @param {string} [org]
         * @param {string} [provider]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assumeRole(role, org, provider, options) {
            return localVarFp.assumeRole(role, org, provider, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} org
         * @param {GithubSlsRestApiEncryptRequest} githubSlsRestApiEncryptRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        encrypt(org, githubSlsRestApiEncryptRequest, options) {
            return localVarFp.encrypt(org, githubSlsRestApiEncryptRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} org
         * @param {boolean} [raw]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgConfig(org, raw, options) {
            return localVarFp.getOrgConfig(org, raw, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} org
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrgMetadata(org, options) {
            return localVarFp.getOrgMetadata(org, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [org]
         * @param {boolean} [refresh]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLogins(org, refresh, options) {
            return localVarFp.listLogins(org, refresh, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOrgRepos(options) {
            return localVarFp.listOrgRepos(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} [org]
         * @param {string} [provider]
         * @param {boolean} [refresh]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoles(org, provider, refresh, options) {
            return localVarFp.listRoles(org, provider, refresh, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} provider
         * @param {string} [org]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerLogin(provider, org, options) {
            return localVarFp.providerLogin(provider, org, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {string} org
         * @param {string} repo
         * @param {boolean} [force]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOrgAndRepo(org, repo, force, options) {
            return localVarFp.setOrgAndRepo(org, repo, force, options).then((request) => request(axios, basePath));
        },
    };
};
exports.IDPApiFactory = IDPApiFactory;
/**
 * IDPApi - object-oriented interface
 * @export
 * @class IDPApi
 * @extends {BaseAPI}
 */
class IDPApi extends base_1.BaseAPI {
    /**
     *
     * @param {string} role
     * @param {string} [org]
     * @param {string} [provider]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    assumeRole(role, org, provider, options) {
        return (0, exports.IDPApiFp)(this.configuration).assumeRole(role, org, provider, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} org
     * @param {GithubSlsRestApiEncryptRequest} githubSlsRestApiEncryptRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    encrypt(org, githubSlsRestApiEncryptRequest, options) {
        return (0, exports.IDPApiFp)(this.configuration).encrypt(org, githubSlsRestApiEncryptRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} org
     * @param {boolean} [raw]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    getOrgConfig(org, raw, options) {
        return (0, exports.IDPApiFp)(this.configuration).getOrgConfig(org, raw, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} org
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    getOrgMetadata(org, options) {
        return (0, exports.IDPApiFp)(this.configuration).getOrgMetadata(org, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} [org]
     * @param {boolean} [refresh]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    listLogins(org, refresh, options) {
        return (0, exports.IDPApiFp)(this.configuration).listLogins(org, refresh, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    listOrgRepos(options) {
        return (0, exports.IDPApiFp)(this.configuration).listOrgRepos(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} [org]
     * @param {string} [provider]
     * @param {boolean} [refresh]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    listRoles(org, provider, refresh, options) {
        return (0, exports.IDPApiFp)(this.configuration).listRoles(org, provider, refresh, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} provider
     * @param {string} [org]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    providerLogin(provider, org, options) {
        return (0, exports.IDPApiFp)(this.configuration).providerLogin(provider, org, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {string} org
     * @param {string} repo
     * @param {boolean} [force]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IDPApi
     */
    setOrgAndRepo(org, repo, force, options) {
        return (0, exports.IDPApiFp)(this.configuration).setOrgAndRepo(org, repo, force, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.IDPApi = IDPApi;
//# sourceMappingURL=api.js.map